diff --git a/.env.example b/.env.example
index c630494..7dd4c05 100644
--- a/.env.example
+++ b/.env.example
@@ -4,6 +4,6 @@ BASE_URL= 'http://localhost:3001'
 ## Endpoint of the otel collector 
 OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318
 ## Authorization header for the otel collector
-OTEL_EXPORTER_OTLP_HEADERS=
+OTEL_EXPORTER_OTLP_HEADERS='Authorization = change_me_in_production'
 ## secret for telemetry token creation
 TELEMETRY_SECRET= 'default_secret_change_me_in_production'
\ No newline at end of file
diff --git a/README.md b/README.md
index 62f106f..2c1927a 100644
--- a/README.md
+++ b/README.md
@@ -176,9 +176,21 @@ TypeScript is configured for strict type checking. The project uses ESLint with
 
 Contributions are welcome! Please feel free to submit a Pull Request.
 
-## License
+## Documentation
+
+The project documentation has been continuously evolved to support both human contributors and AI agents.
+
+### [For Agents & Contributors](docs/AGENTS.md)
+**[Read this first.](docs/AGENTS.md)**
 
-Temp.
+The documentation is organized by role and stability:
+
+-   **[docs/AGENTS.md](docs/AGENTS.md)**: The canonical entry point.
+-   **[docs/roles/](docs/roles/)**: Role-specific guides (Frontend, Backend, Infra, etc.).
+-   **[docs/development/](docs/development/)**: Coding standards and style guides.
+-   **[docs/api/](docs/api/)**: System contracts.
+
+## License
 
 ## Resources
 
diff --git a/docs/README.md b/docs/README.md
deleted file mode 100644
index a3457b8..0000000
--- a/docs/README.md
+++ /dev/null
@@ -1,41 +0,0 @@
-# Project Documentation
-
-This folder contains architecture, security, and development documentation
-for this project.
-
-The documentation is intended for:
-- New contributors onboarding to the project
-- Reviewers understanding architectural decisions
-- Maintaining long-term consistency as the codebase grows
-
----
-
-## Architecture
-
-- [Observability](./architecture/observability.md)  
-  Overview of the observability architecture, telemetry flow, and local vs
-  production setup.
-
-- [Security](./architecture/security.md)  
-  Security architecture, threat considerations, and framework-specific
-  tradeoffs.
-
----
-
-## Development
-
-- [Development Guidelines](./development/guidelines.md)  
-  Coding practices, conventions, and cross-cutting concerns such as
-  observability, security, UI consistency, and testing.
-
-- [Testing](./development/testing.md)  
-  Testing strategy, tools used, and future testing plans.
-
----
-
-## Notes
-
-- Local observability uses Docker for development only
-- Production observability uses Grafana Cloud
-- Documentation is maintained as code and should be updated alongside
-  architectural or behavioral changes
diff --git a/docs/adr/0001-otel-proxy.md b/docs/adr/0001-otel-proxy.md
deleted file mode 100644
index 244155c..0000000
--- a/docs/adr/0001-otel-proxy.md
+++ /dev/null
@@ -1,126 +0,0 @@
-# ADR 0001: Introduce an OpenTelemetry Proxy for Client Telemetry
-
-## Status
-Accepted
-
-## Date
-2026-01-23
-
-## Context
-
-This project collects telemetry (traces, metrics, and logs) from both
-server-side and client-side code.
-
-Directly exporting telemetry from the browser to an OpenTelemetry Collector
-or third-party observability backend introduces several challenges:
-
-- Exposure of collector endpoints and credentials to clients
-- Lack of control over client telemetry volume and payload size
-- Difficulty enforcing security, validation, and redaction policies
-- Risk of telemetry abuse or malformed payloads affecting backend systems
-
-Additionally, the project aims to:
-- Demonstrate production-grade observability practices
-- Maintain clear separation between client and backend infrastructure
-- Support both local (Docker-based) and production (Grafana Cloud) setups
-
----
-
-## Decision
-
-Introduce a **server-side OpenTelemetry proxy** implemented as a Next.js API
-route.
-
-Client-side telemetry is sent to the proxy instead of directly to the
-OpenTelemetry Collector. The proxy is responsible for validation, security,
-and controlled forwarding of telemetry data.
-
----
-
-## Architecture Overview
-
-Client  
-→ Next.js OTEL Proxy (API Route)  
-→ OpenTelemetry Collector  
-→ Backend Systems (Tempo, Prometheus, Loki)
-
----
-
-## Responsibilities of the OTEL Proxy
-
-The proxy performs the following functions:
-
-### Security
-- Validates short-lived telemetry tokens issued to clients
-- Enforces request body size limits
-- Prevents direct exposure of collector endpoints
-- Redacts sensitive information before forwarding
-
-### Observability
-- Creates spans for proxy requests
-- Records upstream latency and error conditions
-- Emits metrics related to proxy usage and failures
-
-### Control & Stability
-- Acts as a choke point for client telemetry volume
-- Allows selective forwarding or rejection of telemetry
-- Enables future sampling or rate-limiting strategies
-
----
-
-## Alternatives Considered
-
-### 1. Direct Client → Collector Export
-**Rejected**
-
-Reasons:
-- Requires exposing collector endpoints publicly
-- Difficult to secure without complex infrastructure
-- Limited ability to validate or constrain telemetry payloads
-- Higher blast radius for client-side misuse
-
----
-
-### 2. Direct Client → Third-Party Backend (e.g. Grafana Cloud)
-**Rejected**
-
-Reasons:
-- Vendor-specific client configuration
-- Credentials or API keys must be exposed to the browser
-- Reduced flexibility for local development and testing
-- Harder to demonstrate vendor-agnostic observability design
-
----
-
-### 3. Disable Client-Side Telemetry
-**Rejected**
-
-Reasons:
-- Loss of valuable client-side performance and error visibility
-- Reduces observability coverage for user-facing flows
-- Not aligned with the project’s educational goals
-
----
-
-## Consequences
-
-### Positive
-- Improved security and control over client telemetry
-- Clear separation between client code and observability infrastructure
-- Consistent telemetry handling across environments
-- Easier to evolve observability strategy over time
-
-### Negative
-- Additional latency for client telemetry ingestion
-- Increased complexity in the backend
-- Proxy itself must be observable and maintained
-
----
-
-## Notes
-
-- The proxy is designed for **controlled telemetry ingestion**, not as a
-  general-purpose API gateway
-- Local development uses Docker-based observability infrastructure
-- Production deployment forwards telemetry to Grafana Cloud via the
-  OpenTelemetry Collector
diff --git a/docs/architecture/observability.md b/docs/architecture/observability.md
deleted file mode 100644
index 2c2ecea..0000000
--- a/docs/architecture/observability.md
+++ /dev/null
@@ -1,146 +0,0 @@
-# Observability Overview
-
-This document introduces the **observability architecture and implementation** used in this project.  
-It is intended for contributors who are new to the codebase and want to understand **how telemetry flows through the system and why it is structured this way**.
-
----
-
-## Observability Stack
-
-Observability in this project is implemented using the three core telemetry signals:
-
-- **Traces**
-- **Metrics**
-- **Logs**
-
-Telemetry is instrumented using **OpenTelemetry** and routed through a dedicated collection and forwarding pipeline.
-
-### Storage Backends
-
-Each telemetry signal is stored in a purpose-built backend:
-
-- **Traces** → Grafana Tempo  
-- **Metrics** → Prometheus  
-- **Logs** → Grafana Loki  
-
----
-
-## Architecture Overview
-
-Telemetry generated by the application does **not** flow directly to backends.  
-Instead, it is routed through a controlled proxy and collection layer.
-
-### High-level Flow
-
-Client
-→ Next.js Application
-→ OTEL Proxy (API boundary)
-→ OpenTelemetry Collector
-→ Telemetry Backends
-
-
-### Signal Routing
-
-- Traces are forwarded to Tempo
-- Metrics are scraped or pushed to Prometheus
-- Logs are forwarded to Loki
-
-This layered approach provides:
-- Centralized authentication and validation
-- Failure isolation (telemetry must never break user flows)
-- Flexibility to swap or reconfigure backends without application changes
-
----
-
-## OTEL Proxy (Why it Exists)
-
-The OTEL Proxy acts as a **network, security, and observability boundary**.
-
-Its responsibilities include:
-- Validating telemetry tokens
-- Enforcing payload size and content-type constraints
-- Forwarding valid telemetry to the collector
-- Recording its own metrics and traces
-- Gracefully handling upstream failures
-
-Importantly:
-> **Failures in telemetry pipelines must never affect user-facing functionality.**
-
----
-
-## OpenTelemetry Collector
-
-The OpenTelemetry Collector is responsible for:
-- Receiving telemetry from the OTEL Proxy
-- Applying processing and batching
-- Forwarding or exposing telemetry to backend systems
-
-The application and proxy remain **backend-agnostic** — all backend-specific configuration lives in the collector.
-
----
-
-## Local vs Production Setup
-
-### Local Development
-
-- A Docker-based setup is used to simulate the full observability stack
-- This includes:
-  - Collector
-  - Tempo
-  - Prometheus
-  - Loki
-  - Grafana
-
-This setup is **strictly for local testing and development**.
-
-> **NOTE:** The Docker setup is not intended for production deployment.
-
-### Production
-
-- Grafana Cloud is used as the managed backend
-- The same OpenTelemetry instrumentation and proxy logic are reused
-- Only collector/exporter configuration differs
-
-This ensures parity between local and production environments while avoiding vendor lock-in in application code.
-
----
-
-## Testing & Guarantees
-
-The behavior of the OTEL Proxy is covered by **integration tests** located at:
-
-`__tests__/integration/otel-proxy.test.ts`
-
-These tests validate the proxy as a system boundary and ensure that:
-
-- Valid telemetry is accepted and forwarded
-- Invalid requests are rejected with correct status codes
-- Upstream collector failures are handled gracefully
-- Telemetry failures do not crash or block the application
-- Observability does not cause fan-out or request amplification
-
-All tests run **without requiring a live collector or backend**, ensuring fast and reliable CI execution.
-
----
-
-## Non-goals
-
-The observability implementation intentionally does **not** aim to:
-
-- Validate OpenTelemetry SDK internals
-- Enforce OTLP schema correctness
-- Guarantee backend-side ingestion or storage
-- Provide performance benchmarking
-
-Those concerns are delegated to backend systems and runtime monitoring.
-
----
-
-## Summary
-
-This observability architecture prioritizes:
-
-- **Safety** — telemetry must never break application behavior
-- **Isolation** — failures are contained within observability boundaries
-- **Flexibility** — backends can change without code changes
-- **Testability** — all critical behavior is covered by integration tests
diff --git a/docs/architecture/security.md b/docs/architecture/security.md
deleted file mode 100644
index 476454a..0000000
--- a/docs/architecture/security.md
+++ /dev/null
@@ -1,21 +0,0 @@
-This document is for people new to this project to understand the security architecture and implementation.
-
-In-Memory IP-based Rate Limiting is applied in the middleware.ts. We are also checking the content lenght of request body depending on the path in which the request is applied which is defined in the config. 
-We perform Nonce generation for CSP. 
-
-In route api/otel/trace content lenght check by reading stream using functionality defined contentLength.ts. Short lived telemetry token created for client traces which are verified in the handler.
-
-Redacting Sensitive information configure in otel initialization.
-
-Due to App Router limitations, Next.js-managed scripts and styles cannot be fully nonced. This CSP setup prioritizes script execution safety while allowing framework-managed styles.
-
-## Threat Model (High Level)
-
-Out of Scope:
-- Distributed denial-of-service attacks
-- Advanced bot detection
-
-In Scope:
-- Excessive request payloads
-- Client-side telemetry abuse
-- Script injection via CSP violations
diff --git a/docs/development/guidelines.md b/docs/development/guidelines.md
deleted file mode 100644
index 38d527b..0000000
--- a/docs/development/guidelines.md
+++ /dev/null
@@ -1,160 +0,0 @@
-# Development Guidelines
-
-This document describes the coding practices, conventions, and cross-cutting
-concerns to follow when contributing to this project.
-
-The goal is to ensure consistency, security, observability, and maintainability
-as the codebase grows.
-
----
-
-## General Principles
-
-- Prefer **clarity over cleverness**
-- Treat **observability and security as first-class concerns**
-- Keep implementations **predictable and explicit**
-- Optimize for **testability, readability and debuggability**, not premature performance
-
----
-
-## Project Structure
-
-- App Router is used (`app/`)
-- API routes live under `app/api`
-- Shared logic should live in `lib/`
-- Cross-cutting utilities (otel, security, config) must not leak into UI code
-
-Avoid tightly coupling:
-- UI components with API logic
-- Business logic with framework-specific APIs
-
----
-
-## API Route Development
-
-When creating or modifying an API route, ensure the following:
-
-### 1. Observability
-
-Every API route **must**:
-- Create or participate in a trace
-- Emit meaningful span names
-- Record errors using span status and logs
-- Include relevant attributes (route, method, status)
-
-Avoid:
-- Silent failures
-- Catching errors without logging or tracing
-
-Example considerations:
-- Is latency measurable?
-- Can failures be correlated across services?
-
----
-
-### 2. Security
-
-Each API route should explicitly consider:
-- Request body size limits
-- Input validation
-- Authentication / authorization (if applicable)
-- Abuse potential (rate limiting, replay, telemetry misuse)
-
-Rules:
-- Never trust client-provided headers blindly
-- Validate telemetry tokens and short-lived credentials
-- Redact sensitive data before logging or exporting telemetry
-
----
-
-### 3. Error Handling
-
-- Prefer explicit error responses
-- Do not leak internal error details to clients
-- Log internal errors with sufficient context for debugging
-
----
-
-## Frontend Development
-
-### Responsiveness
-
-All frontend pages must:
-- Be usable on mobile, tablet, and desktop
-- Avoid hardcoded widths
-- Use layout primitives consistently
-
-Test pages at:
-- Small mobile viewport
-- Standard desktop viewport
-- Dark mode and Light mode
----
-
-### UI Consistency
-
-- Reuse existing components and patterns
-- Avoid introducing one-off UI behaviors
-- Follow existing spacing, typography, and layout conventions
-
-If a new pattern is required:
-- Abstract it into a reusable component
-- Document its intended usage
-
----
-
-### Performance Considerations
-
-- Avoid unnecessary client-side JavaScript
-- Prefer server components when possible
-- Lazy-load heavy or non-critical components
-
----
-
-## Logging & Telemetry
-
-- Logs should be structured and meaningful
-- Avoid logging large payloads
-- Never log secrets, tokens, or PII
-
-Telemetry should:
-- Help answer “what happened?” and “why?”
-- Be actionable, not noisy
-- Serve both debugging and performance analysis
-
----
-
-## Testing Guidelines
-
-- Write unit tests for isolated logic
-- Write integration tests for component interactions
-- Tests should be deterministic and fast
-
-Avoid:
-- Snapshot overuse
-- Testing implementation details instead of behavior
-
----
-
-## Configuration & Environment
-
-- Do not hardcode environment-specific values
-- Use configuration files and environment variables
-- Clearly document assumptions about local vs production behavior
-
----
-
-## Code Review Checklist (Self-Review)
-
-Before submitting code, ask:
-- Is this observable in production?
-- Is this secure against basic abuse?
-- Is this consistent with existing patterns?
-- Will a new contributor understand this in 6 months?
-
----
-
-## Documentation
-
-- Update relevant docs when behavior changes
-- Architecture or security changes must be documented
-- Prefer short, clear explanations over exhaustive detail
diff --git a/docs/development/testing.md b/docs/development/testing.md
deleted file mode 100644
index 980aa0d..0000000
--- a/docs/development/testing.md
+++ /dev/null
@@ -1,166 +0,0 @@
-# Testing Strategy
-
-This document describes the testing philosophy, structure, and guarantees for this project.
-
-The goal of the test suite is **system stability and correctness**, not model quality or performance benchmarking.
-
----
-
-## 1. Testing Philosophy
-
-This project follows a layered testing approach:
-
-- **Unit tests** validate isolated logic and pure functions
-- **Integration tests** validate interaction between subsystems
-- **E2E tests** validate user-critical flows (planned)
-
-The test suite prioritizes:
-- Correct rendering and responses
-- Stability of critical paths
-- Resilience to observability and infrastructure failures
-
----
-
-## 2. Test Strategy Overview
-
-### Unit Tests
-- Focus on deterministic, isolated logic
-- Fast to run, minimal mocking
-- Failures should clearly identify the faulty unit
-
-### Integration Tests
-- Validate orchestration across multiple components
-- Assert **behavioral outcomes**, not implementation details
-- Enforce system-level guarantees (auth, observability, error handling)
-
-### E2E Tests (Planned)
-- Validate real user flows in a browser environment
-- Implemented using Playwright
-
----
-
-## 3. Tooling
-
-This project uses:
-
-- **Jest** — test runner and mocking
-- **React Testing Library** — UI and interaction testing
-
-Configuration lives in:
-- `jest.config.ts`
-
-### Running Tests
-- Run all tests: `pnpm test`
-- Watch mode: `pnpm test:watch`
-
----
-
-## 4. Test Organization
-
-Tests live in the `__tests__` directory and mirror the source structure where possible.
-
-```
-__tests__/
-├── api/ # API route integration tests
-├── integration/ # Cross-system integration tests
-├── lib/ # Unit + integration tests for libraries
-├── components/ # UI component tests
-```
-
----
-
-## 5. Mocking & Boundary Philosophy
-
-Mocks are applied **only at external or non-deterministic boundaries**.
-
-### Real implementations are preferred for:
-- Business logic
-- Orchestration flow
-- State transitions
-
-### Mocks are used for:
-- ONNX runtime (browser/WASM dependency)
-- External APIs or services beyond local control
-- Observability exporters (metrics, tracing backends)
-
-### Infrastructure Helpers
-
-Helpers such as `safeMetric` are mocked to preserve **semantic behavior**:
-
-- The wrapped function executes
-- Errors are swallowed
-- Tests validate system resilience, not helper internals
-
----
-
-## 6. Coverage Guarantees (Integration Invariants)
-
-Integration tests enforce the following system-level guarantees:
-
-### Observability Safety
-- Failures in metrics, tracing, or logging **must not break user-facing functionality**
-- Example: the `telemetry-token` API returns `200` even if metric recording throws
-
-### LLM Orchestration
-- Tokenization, inference loop, sampling, and telemetry are validated together
-- Numerical correctness and model quality are intentionally out of scope
-
-### Behavior-First Validation
-- Tests assert observable behavior (responses, UI state, side effects)
-- Internal method calls are not asserted unless crossing a subsystem boundary
-
----
-
-## 7. Key Coverage Areas
-
-- **API Routes**: `__tests__/api`  
-  Example: telemetry-token route integration tests
-
-- **LLM Orchestration**: `__tests__/lib/llm`  
-  Verifies interaction between the ONNX runtime, tokenizer, sampling logic, and OpenTelemetry
-
-- **UI Components**: `__tests__/components`  
-  Verifies interaction between UI state, user input, and LLM client services
-
----
-
-## 8. Integration Tests: OpenTelemetry Proxy
-
-The OpenTelemetry trace proxy (`app/api/otel/trace/route.ts`) is treated as a **network and security boundary**.
-
-Integration tests live at:
-
-`__tests__/integration/otel-proxy.test.ts`
-
-### Guarantees
-- Valid trace payloads are accepted and forwarded
-- Invalid requests (auth, payload size, content-type) are rejected correctly
-- Upstream failures are handled gracefully (no crashes)
-- No observational fan-out (1 request → 1 proxy span)
-
-### Mocked Boundaries
-- Upstream collector (`global.fetch`)
-- Observability exporters (metrics and tracing backends)
-
-### Limitations
-- Does NOT validate OTLP schema correctness
-- Does NOT test OpenTelemetry SDK internals
-- Does NOT guarantee upstream collector processing
-
----
-
-## 9. Non-goals
-
-The following are intentionally out of scope:
-
-- Numerical correctness of LLM outputs
-- LLM performance benchmarking
-- OpenTelemetry SDK internals
-- Browser-based E2E testing (planned)
-
----
-
-## 10. Future Plans
-
-- End-to-end testing with Playwright
-- LLM evaluations and quality metrics
